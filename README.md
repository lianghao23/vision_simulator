# Daedalus: RoboMaster 视觉算法验证模拟器

这是一个专为 **Actor&Thinker 战队** 开发的 **RoboMaster 视觉算法验证模拟器**，用于在虚拟环境中测试和验证机器人视觉算法。

## 🚀 功能亮点

- 🎯 **视觉算法验证**：可在模拟环境中测试目标检测、可见性判断等算法
- 🕹️ **交互模拟**：支持 RoboMaster 机器人动作与状态模拟
- ⚡ **高效渲染**：基于 Bevy 引擎，支持 CPU/GPU 渲染
- 🔧 **易用性**：开箱即用，只需执行 `cargo run --release` 即可启动模拟器
- 🧪 **实验平台**：一键对接 ROS2，无缝运行模拟程序

## 🎨 资源支持与功能规划

### ✅ 已实现功能

- [x] 大、小能量机关激活流程完整模拟 (外观与基本功能)
- [x] AM02 装甲模块图案 (部分图案)
- [x] 多视角切换(自由/第一人称/第三人称)
- [x] 基础机器人控制与交互
- [x] ROS2 基本集成

### 🔄 近期开发计划

- [ ] **装甲模块、能量机关仿真数据集导出**
- [ ] **ROS2 自定义外参，订阅 infantry 操作指令**
- [ ] **前哨站外观与基本功能**
- [ ] **雷达站功能模拟** (小地图构建、敌方位置投影)

### 🚀 高级功能规划

- [ ] **灯条颜色切换** - 模拟机器人状态指示灯
- [ ] **多机器人协同模拟**（步兵、英雄、哨兵）
- [ ] **弹道模拟与落点校准验证**
- [ ] **相机参数模拟**（曝光、白平衡、畸变）
- [ ] **不同光照条件模拟**

## 💡 使用说明

### ROS2 集成规划

- **话题发布**：`/camera_info` `/image_raw` `image_compressed` (模拟图像流)
- **话题发布**：`/tf`
- **话题发布**：`/gimbal_pose` `odom_pose` `camera_pose`

### 控制说明

#### 1️⃣ 自己的 Infantry（玩家 1）

| 功能   | 按键              | 说明                                    |
|------|-----------------|---------------------------------------|
| 移动   | `W` `A` `S` `D` | 前后左右移动                                |
| 底盘旋转 | `Q` `E`         | 底盘左右旋转                                |
| 发射弹丸 | `Space`         | 发射弹丸                                  |
| 云台旋转 | `↑` `↓` `←` `→` | 手动控制云台俯仰和偏航                           |
| 自动瞄准 | `T`             | 切换自动瞄准模式（屏幕显示 `gimbal=AUTO-AIM/MANUAL`） |

#### 2️⃣ 另一个 Infantry（玩家 2 / 靶车）

| 功能   | 按键              | 说明                                      |
|------|-----------------|-------------------------------------------|
| 移动   | `I` `J` `K` `L` | 前后左右移动（手动模式）                              |
| 底盘旋转 | `U` `O`         | 底盘左右旋转（手动模式）                              |
| 云台旋转 | `F` `V` `C` `B` | 手动控制云台俯仰和偏航                               |
| 自动运动 | `P`             | 切换自动运动模式（屏幕显示 `target=AUTO-MOVE/MANUAL`） |

**自动运动说明**：
- 启用后，靶车将在 5 米范围内沿直线往复运动
- 同时保持自转（默认 0.4 转/秒）
- 自动运动时无法手动控制移动和底盘旋转

#### 3️⃣ 自由视角

| 功能   | 操作                        |
|------|---------------------------|
| 移动   | `W` `A` `S` `D` + `N` `J` |
| 视角旋转 | 鼠标拖动                      |

### 👀 视角切换

- **F3**：切换视角模式
    - **自由视角** - 全局观察，适合算法调试
    - **第一人称视角** - 操作手视角，测试实际效果
    - **第三人称视角** - 机器人行为观察

### 📷 实用功能

- **F2**：截取当前画面（含标注信息）
- **F4**：显示/隐藏调试信息
- **F5**：重新加载场景

## ⚙️ 参数调整

### 控制灵敏度参数

在 [src/main.rs](src/main.rs) 中可以调整以下参数（约 527-532 行）：

```rust
// 单位 m/s²
const VEHICLE_ACCEL: f32 = 10.0;  // 车辆加速度
// 单位 rad/s
const VEHICLE_ROTATION_SPEED: f32 = 3.0;  // 车辆底盘旋转速度
const GIMBAL_ROTATION_SPEED: f32 = 5.0;   // 云台旋转速度（手动控制灵敏度）

const MAX_VEHICLE_VELOCITY: f32 = 6.0;  // 车辆最大速度（m/s）
```

**参数说明**：

| 参数 | 单位 | 默认值 | 说明 |
|------|------|--------|------|
| `VEHICLE_ACCEL` | m/s² | 10.0 | 车辆加速度，控制 WASD/IJKL 按键响应速度。值越大，启动和停止越快 |
| `VEHICLE_ROTATION_SPEED` | rad/s | 3.0 | 车辆底盘旋转速度（QE/UO 按键）。值越大，转向越快 |
| `GIMBAL_ROTATION_SPEED` | rad/s | 5.0 | 云台旋转速度（方向键控制）。**值越大，云台手动控制越灵敏** |
| `MAX_VEHICLE_VELOCITY` | m/s | 6.0 | 车辆最大移动速度限制 |

**调整云台灵敏度示例**：
- 如果觉得云台转动太快，可以将 `GIMBAL_ROTATION_SPEED` 改为 `3.0` 或更小
- 如果觉得云台转动太慢，可以将其改为 `8.0` 或更大

### 靶车自动运动参数

在 [src/main.rs](src/main.rs) 中的 `AutoMoveConfig` 结构体（约 48-63 行）：

```rust
#[derive(Resource)]
struct AutoMoveConfig {
    range: f32,           // 往复运动范围（米）
    min_speed: f32,       // 最小平均速度（米/秒）
    rotation_speed: f32,  // 自转速度（转/秒）
}

impl Default for AutoMoveConfig {
    fn default() -> Self {
        Self {
            range: 5.0,           // 5 米往返范围
            min_speed: 1.0,       // 最小 1 m/s
            rotation_speed: 0.4,  // 0.4 转/秒
        }
    }
}
```

**参数说明**：

| 参数 | 单位 | 默认值 | 说明 |
|------|------|--------|------|
| `range` | 米 | 5.0 | 靶车往复运动的距离范围 |
| `min_speed` | m/s | 1.0 | 靶车平移的最小平均速度 |
| `rotation_speed` | 转/秒 | 0.4 | 靶车自转速度（1.0 = 每秒旋转一圈） |

## 📝 开发者信息

- **作者**: Blackjack200
- **团队**: Actor&Thinker 战队
- **技术栈**: Rust + Bevy + ROS2
- **联系方式**: 可通过 GitHub Issues 或 PR 讨论功能
- **开源协议**: [待确定]

## 🌄 演示图片

<div style="text-align: center;">
    <img src="demo.png" style="width: 75%;">
</div>

## 📜 开源协议

**AGPL v3** - 因为我们相信开放基础技术能够激发整个社区的创新活力

### 为什么选择这个协议？

- **🌱 播撒技术种子**：开放核心框架，为 RoboMaster 社区提供坚实的技术基础
- **🚀 激发集体智慧**：让更多战队能在我们的基础上探索新的可能性
- **💡 推动技术演进**：通过社区协作，共同推动视觉算法技术的边界

我们选择开放仿真技术，因为我们深知真正的技术在于持续创造价值的能力。这种开放与协作的结合，让我们能够共同构建更加繁荣的技术生态。